<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>테트리스</title>
<style>
  body { background: #222; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin-top: 20px; }
  #score { font-size: 20px; margin-bottom: 10px; }
  #game { display: grid; grid-template-rows: repeat(20, 30px); grid-template-columns: repeat(10, 30px); gap: 1px; margin-bottom: 10px; }
  .cell { width: 30px; height: 30px; background: #111; border: 1px solid #333; }
  #overlay { position: absolute; top:0; left:0; width:100%; height:100%; display:flex; justify-content:center; align-items:center; background:rgba(0,0,0,0.8); flex-direction:column; }
  button { font-size: 20px; padding: 10px 20px; cursor:pointer; margin-top: 10px; }
</style>
</head>
<body>

<div id="score">점수: 0</div>
<div id="game"></div>

<div id="overlay">
  <h1>테트리스</h1>
  <button id="startBtn">게임 시작</button>
</div>

<script>
const ROWS = 20, COLS = 10;
const game = document.getElementById("game");
const scoreDiv = document.getElementById("score");
const overlay = document.getElementById("overlay");
const startBtn = document.getElementById("startBtn");

let score = 0;
let interval;
let isRunning = false;

// 그리드 생성
let grid = [];
for(let r=0;r<ROWS;r++){
    let row=[];
    for(let c=0;c<COLS;c++){
        const cell=document.createElement("div");
        cell.classList.add("cell");
        game.appendChild(cell);
        row.push(cell);
    }
    grid.push(row);
}

// 테트리스 블록 모양과 색상
const TETROMINOES = [
    {shape:[[[1,1,1,1]], [[1],[1],[1],[1]]], color:"#00f0f0"}, // I
    {shape:[[[1,1],[1,1]]], color:"#f0f000"}, // O
    {shape:[[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]], color:"#a000f0"}, // T
    {shape:[[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]], color:"#00f000"}, // S
    {shape:[[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]], color:"#f00000"}, // Z
    {shape:[[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]], color:"#f0a000"}, // L
    {shape:[[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]], color:"#0000f0"}  // J
];

// 현재 블록
let current;

// 충돌 체크
function collision(x,y,shape){
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let newY = y+r;
                let newX = x+c;
                if(newX<0 || newX>=COLS || newY>=ROWS) return true;
                if(newY>=0 && grid[newY][newX].dataset.static==="true") return true;
            }
        }
    }
    return false;
}

// 블록 고정
function fixBlock(){
    const shape = current.tetromino.shape[current.rotation];
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let y = current.y+r;
                let x = current.x+c;
                if(y>=0){
                    grid[y][x].dataset.static="true";
                    grid[y][x].style.background = current.tetromino.color;
                }
            }
        }
    }
    clearLines();
}

// 라인 제거
function clearLines(){
    for(let r=ROWS-1;r>=0;r--){
        let full = true;
        for(let c=0;c<COLS;c++){
            if(grid[r][c].dataset.static!=="true"){
                full = false;
                break;
            }
        }
        if(full){
            score += 100;
            for(let row=r; row>0; row--){
                for(let c=0;c<COLS;c++){
                    grid[row][c].dataset.static = grid[row-1][c].dataset.static;
                    grid[row][c].style.background = grid[row-1][c].style.background;
                }
            }
            for(let c=0;c<COLS;c++){
                grid[0][c].dataset.static = "";
                grid[0][c].style.background = "#111";
            }
            r++;
        }
    }
    scoreDiv.textContent = "점수: "+score;
}

// 새 블록 생성
function newBlock(){
    current = {
        tetromino: TETROMINOES[Math.floor(Math.random()*TETROMINOES.length)],
        rotation: 0,
        x: 3,
        y: 0
    };
    if(collision(current.x,current.y,current.tetromino.shape[current.rotation])){
        gameOver();
    }
}

// 고스트 위치
function getGhostY(){
    const shape = current.tetromino.shape[current.rotation];
    let ghostY = current.y;
    while(!collision(current.x, ghostY+1, shape)){
        ghostY++;
    }
    return ghostY;
}

// 블록 그리기
function draw(){
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(grid[r][c].dataset.static!=="true"){
                grid[r][c].style.background="#111";
            }
        }
    }

    const shape = current.tetromino.shape[current.rotation];
    const ghostY = getGhostY();

    // 고스트 블록
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let y = ghostY+r;
                let x = current.x+c;
                if(y>=0 && grid[y][x].dataset.static!=="true"){
                    grid[y][x].style.background = hexToRGBA(current.tetromino.color,0.3);
                }
            }
        }
    }

    // 현재 블록
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let y = current.y+r;
                let x = current.x+c;
                if(y>=0) grid[y][x].style.background = current.tetromino.color;
            }
        }
    }
}

function hexToRGBA(hex, alpha){
    let r=parseInt(hex.substr(1,2),16);
    let g=parseInt(hex.substr(3,2),16);
    let b=parseInt(hex.substr(5,2),16);
    return `rgba(${r},${g},${b},${alpha})`;
}

// 블록 이동
function move(dx,dy){
    const shape = current.tetromino.shape[current.rotation];
    if(!collision(current.x+dx,current.y+dy,shape)){
        current.x+=dx;
        current.y+=dy;
    } else if(dy===1){
        fixBlock();
        newBlock();
    }
    draw();
}

// 회전
function rotate(){
    let nextRotation = (current.rotation + 1) % current.tetromino.shape.length;
    if(!collision(current.x,current.y,current.tetromino.shape[nextRotation])){
        current.rotation = nextRotation;
    }
    draw();
}

// 스페이스바 즉시 낙하
function drop(){
    const shape = current.tetromino.shape[current.rotation];
    while(!collision(current.x,current.y+1,shape)){
        current.y++;
    }
    fixBlock();
    newBlock();
    draw();
}

// 키 입력
document.addEventListener("keydown",(e)=>{
    if(!isRunning) return;
    if(e.key==="ArrowLeft") move(-1,0);
    if(e.key==="ArrowRight") move(1,0);
    if(e.key==="ArrowDown") move(0,1);
    if(e.key==="ArrowUp") rotate();
    if(e.key===" ") drop();
});

// 게임 시작
startBtn.addEventListener("click", ()=>{
    overlay.style.display="none";
    startGame();
});

function startGame(){
    score=0;
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            grid[r][c].dataset.static="";
            grid[r][c].style.background="#111";
        }
    }
    isRunning=true;
    newBlock();
    draw();
    interval = setInterval(()=>{ move(0,1); },500);
}

// 게임 종료
function gameOver(){
    clearInterval(interval);
    isRunning=false;
    overlay.innerHTML = `<h1>게임 종료</h1><p>점수: ${score}</p><button id="restartBtn">다시 시작</button>`;
    overlay.style.display="flex";
    document.getElementById("restartBtn").addEventListener("click", ()=>{
        overlay.innerHTML = `<h1>테트리스</h1><button id="startBtn">게임 시작</button>`;
        document.getElementById("startBtn").addEventListener("click", ()=>{
            overlay.style.display="none";
            startGame();
        });
    });
}

</script>
</body>
</html>
