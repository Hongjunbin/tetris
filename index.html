<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>테트리스</title>
<style>
  body { background: #222; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin-top: 20px; }
  #score { font-size: 20px; margin-bottom: 10px; }
  #game { display: grid; grid-template-rows: repeat(20, 30px); grid-template-columns: repeat(10, 30px); gap: 1px; }
  .cell { width: 30px; height: 30px; background: #111; border: 1px solid #333; }
</style>
</head>
<body>

<div id="score">점수: 0</div>
<div id="game"></div>

<script>
const ROWS = 20, COLS = 10;
const game = document.getElementById("game");
const scoreDiv = document.getElementById("score");
let score = 0;

// 그리드 생성
let grid = [];
for(let r=0;r<ROWS;r++){
    let row=[];
    for(let c=0;c<COLS;c++){
        const cell=document.createElement("div");
        cell.classList.add("cell");
        game.appendChild(cell);
        row.push(cell);
    }
    grid.push(row);
}

// 테트리스 블록 모양과 색상
const TETROMINOES = [
    {shape:[[[1,1,1,1]], [[1],[1],[1],[1]]], color:"#00f0f0"}, // I - 시안
    {shape:[[[1,1],[1,1]]], color:"#f0f000"}, // O - 노랑
    {shape:[[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]], color:"#a000f0"}, // T - 보라
    {shape:[[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]], color:"#00f000"}, // S - 초록
    {shape:[[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]], color:"#f00000"}, // Z - 빨강
    {shape:[[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]], color:"#f0a000"}, // L - 주황
    {shape:[[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]], color:"#0000f0"}  // J - 파랑
];

// 현재 블록 정보
let current = {
    tetromino: TETROMINOES[Math.floor(Math.random()*TETROMINOES.length)],
    rotation: 0,
    x: 3,
    y: 0
};

// 충돌 체크
function collision(x,y,shape){
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let newY = y+r;
                let newX = x+c;
                if(newX<0 || newX>=COLS || newY>=ROWS) return true;
                if(newY>=0 && grid[newY][newX].dataset.static==="true") return true;
            }
        }
    }
    return false;
}

// 블록 고정
function fixBlock(){
    const shape = current.tetromino.shape[current.rotation];
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let y = current.y+r;
                let x = current.x+c;
                if(y>=0){
                    grid[y][x].dataset.static="true";
                    grid[y][x].style.background = current.tetromino.color;
                }
            }
        }
    }
    clearLines();
}

// 라인 제거
function clearLines(){
    for(let r=ROWS-1;r>=0;r--){
        let full = true;
        for(let c=0;c<COLS;c++){
            if(grid[r][c].dataset.static!=="true"){
                full = false;
                break;
            }
        }
        if(full){
            score += 100;
            for(let row=r; row>0; row--){
                for(let c=0;c<COLS;c++){
                    grid[row][c].dataset.static = grid[row-1][c].dataset.static;
                    grid[row][c].style.background = grid[row-1][c].style.background;
                }
            }
            for(let c=0;c<COLS;c++){
                grid[0][c].dataset.static = "";
                grid[0][c].style.background = "#111";
            }
            r++; // 다시 같은 줄 체크
        }
    }
    scoreDiv.textContent = "점수: "+score;
}

// 새 블록 생성
function newBlock(){
    current = {
        tetromino: TETROMINOES[Math.floor(Math.random()*TETROMINOES.length)],
        rotation: 0,
        x: 3,
        y: 0
    };
    if(collision(current.x,current.y,current.tetromino.shape[current.rotation])){
        alert("게임 종료! 점수: "+score);
        location.reload();
    }
}

// 고스트 블록 위치 계산
function getGhostY(){
    const shape = current.tetromino.shape[current.rotation];
    let ghostY = current.y;
    while(!collision(current.x, ghostY+1, shape)){
        ghostY++;
    }
    return ghostY;
}

// 블록 그리기
function draw(){
    // 전체 초기화
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(grid[r][c].dataset.static!=="true"){
                grid[r][c].style.background="#111";
            }
        }
    }

    const shape = current.tetromino.shape[current.rotation];
    const ghostY = getGhostY();

    // 고스트 블록 표시
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let y = ghostY+r;
                let x = current.x+c;
                if(y>=0 && grid[y][x].dataset.static!=="true"){
                    grid[y][x].style.background = hexToRGBA(current.tetromino.color,0.3);
                }
            }
        }
    }

    // 현재 블록 표시
    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                let y = current.y+r;
                let x = current.x+c;
                if(y>=0) grid[y][x].style.background = current.tetromino.color;
            }
        }
    }
}

// 헥스 색상 -> RGBA 변환
function hexToRGBA(hex, alpha){
    let r=parseInt(hex.substr(1,2),16);
    let g=parseInt(hex.substr(3,2),16);
    let b=parseInt(hex.substr(5,2),16);
    return `rgba(${r},${g},${b},${alpha})`;
}

// 블록 이동
function move(dx,dy){
    const shape = current.tetromino.shape[current.rotation];
    if(!collision(current.x+dx,current.y+dy,shape)){
        current.x+=dx;
        current.y+=dy;
    } else if(dy===1){
        fixBlock();
        newBlock();
    }
    draw();
}

// 블록 회전
function rotate(){
    let nextRotation = (current.rotation + 1) % current.tetromino.shape.length;
    if(!collision(current.x,current.y,current.tetromino.shape[nextRotation])){
        current.rotation = nextRotation;
    }
    draw();
}

// 스페이스바 즉시 낙하
function drop(){
    const shape = current.tetromino.shape[current.rotation];
    while(!collision(current.x,current.y+1,shape)){
        current.y++;
    }
    fixBlock();
    newBlock();
    draw();
}

// 키 입력
document.addEventListener("keydown",(e)=>{
    if(e.key==="ArrowLeft") move(-1,0);
    if(e.key==="ArrowRight") move(1,0);
    if(e.key==="ArrowDown") move(0,1);
    if(e.key==="ArrowUp") rotate();
    if(e.key===" ") drop();
});

// 자동 낙하
setInterval(()=>{ move(0,1); }, 500);

// 초기 렌더
draw();
</script>

</body>
</html>
